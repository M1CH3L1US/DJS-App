import { Channel, Client, Role, User } from 'discord.js';

import { IToken } from './token.interface';

export type TNewLineCharacter = "\n" | "\r" | "\r\n";

export enum CommandTokenKind {
  /**
   * A user mention is formatted as follows: `<@USER_ID>`
   * and parsed using the {@link USER_MENTION_REGEXP}
   * regular expression.
   */
  UserMention,
  /**
   * A channel mention is formatted as follows: `<#CHANNEL_ID>`
   * and parsed using the {@link CHANNEL_MENTION_REGEXP}
   * regular expression.
   */
  ChannelMention,
  /**
   * A role mention is formatted as follows: `<@&CHANNEL_ID>`
   * and parsed using the {@link ROLE_MENTION_REGEXP}
   * regular expression.
   */
  RoleMention,
  /**
   * Double quoted string literal - `"`
   * Expandable strings could reference variables
   * in future releases
   */
  StringExpandable,
  /** Single quoted string literal - `'` */
  StringLiteral,
  /** A string string literal quoted with a single back tick - '`' */
  StringTemplate,
  /** Any numeric literal */
  Number,
  /**
   * A code block starts with three back-ticks and is ended accordingly
   * ```
   * \`\`\`ts
   *  const a = "Beep Boop";
   * \`\`\`
   * ```
   */
  CodeBlock,
  /**
   * An identifier is either a keyword
   * or a variable.
   */
  Identifier,
  /**
   * The length of the prefix used is passed to the tokenizer
   * after it was determined in the command pipeline. It has
   * to be determined before the message is tokenized to make
   * sure a given message could possibly be a command.
   *
   * A prefix can be any character / characters formatted
   * like it was specified by the prefix configuration.
   *
   * @see {@link ICommandPrefix}
   */
  Prefix,
  /** Text prefixed with a Dash or DoubleDash is treated as a parameter */
  Parameter,
  /**
   * Message content that could not be matched with any kind
   * @example
   * `!ban @BeepBoop being too cute 24`
   * Would would result in:
   * `!`          - Prefix,
   * `ban`        - Command,
   * `@BeepBoop`  - UserMention,
   * `being`      - Generic
   * `too`        - Generic
   * `cute`       - Generic,
   * `24`         - Number
   *
   * If the matched command accepts less arguments than
   * the amount of parsed arguments and contains generic arguments
   * Watson will try to figure out the correct argument by
   * adding a parsed argument following or preceding a generic back
   * to its original.
   */
  Generic,
  /** A dash for command arguments - '-' */
  Dash,
  /** A double dash for command arguments - '--' */
  DashDash,
  /** A new line character - '\n', '\r', or '\r\n' */
  NewLine,
  /** A white space character - '\w', ' ', or '\w+' */
  WhiteSpace,
  /** End of the message */
  Eom,
}

export interface ICommandToken extends IToken<CommandTokenKind> {}

export interface ITokenWithValue<T> extends ICommandToken {
  value: T;
}

/** @see {@link CommandTokenKind#Prefix} */
export interface IPrefixToken extends ICommandToken {}

/** @see {@link CommandTokenKind#UserMention} */
export interface IUserMentionToken extends ITokenWithValue<string> {
  getId(): string;
  getUser(client: Client): Promise<User>;
}
/** @see {@link CommandTokenKind#ChannelMention} */
export interface IChannelMentionToken extends ITokenWithValue<string> {
  getId(): string;
  getChannel(client: Client): Promise<Channel>;
}
/** @see {@link CommandTokenKind#RoleMention} */
export interface IRoleMentionToken extends ITokenWithValue<string> {
  getId(): string;
  getRole(client: Client): Promise<Role>;
}

/** @see {@link CommandTokenKind#CodeBlock} */
export interface ICodeBlockToken extends ITokenWithValue<string> {
  language: string;
}

/** @see {@link CommandTokenKind#StringExpandable} */
export interface IStringExpandableToken extends ITokenWithValue<string> {}
/** @see {@link CommandTokenKind#StringLiteral} */
export interface IStringLiteralToken extends ITokenWithValue<string> {}
/** @see {@link CommandTokenKind#StringTemplate} */
export interface IStringTemplateToken extends ITokenWithValue<string> {}
/** @see {@link CommandTokenKind#Number} */
export interface INumberToken extends ITokenWithValue<number> {}

/** @see {@link CommandTokenKind#Generic} */
export interface IGenericToken extends ICommandToken {}

// TODO: Allow variables and keywords in template / expandable strings
/** @see {@link CommandTokenKind#Identifier} */
export interface IIdentifierToken extends ITokenWithValue<string> {}

/** @see {@link CommandTokenKind#Parameter} */
export interface IParameterToken extends ITokenWithValue<string> {
  doubleDashed: boolean;
}

/**
 * The following token types are not generated by the
 * default tokenizer.
 */

/** @see {@link CommandTokenKind#NewLine} */
export interface INewLineToken extends ICommandToken {}
/** @see {@link CommandTokenKind#WhiteSpace} */
export interface IWhiteSpaceToken extends ICommandToken {}
/** @see {@link CommandTokenKind#EOM} */
export interface IEndOfMessageToken extends ICommandToken {}
/** @see {@link CommandTokenKind#Dash} */
export interface IDashToken extends ICommandToken {}
/** @see {@link CommandTokenKind#DashDash} */
export interface IDashDashToken extends ICommandToken {}
